<!doctype html>
<html role="api-designer">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>API Designer</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width">

  <link rel="stylesheet" href="styles/api-designer-vendor.css"/>

  <link rel="stylesheet" href="styles/api-designer.css"/>
</head>
<body ng-app="ramlEditorApp">
<div class="container">
  <raml-editor></raml-editor>
</div>

<script src="scripts/api-designer-vendor.js"></script>

<script src="scripts/api-designer.js"></script>
<script>
  angular.module('ramlEditorApp')
    .constant('URL','/files/')
    .constant('FOLDER', 'folder')
    .factory('MyFileSystemHelper', function ($http, URL) {
      return {
        forEach: function (fn) {
          $http({
            method: 'GET',
            data: '',
            url: URL,
            withCredentials: false
          }).success(function (data) {
            Object.keys(data).forEach(function (id) {
              fn(JSON.parse(data[id]));
            });
          });
        },
        has: function (path) {
          var has = false;
          path = path || '/';
          this.forEach(function (entry) {
            if (entry.path.toLowerCase() === path.toLowerCase()) {
              has = true;
            }
          });
          return has;
        },
        set: function(path, content) {
          $http({
            method: 'POST',
            data: JSON.stringify(content),
            url: URL,
            withCredentials: false
          });
        },
        get: function(path) {
          $http({
            method: 'GET',
            data: '',
            url: URL + files[path],
            withCredentials: false
          }).success(function (data) {
            return JSON.parse(data);
          });
        },
        remove: function(path) {
          $http({
            method: 'DELETE',
            data: '',
            url: URL + files[path],
            withCredentials: false
          });
        }
      }
    })
    .factory('MyFileSystem', function ($q, $window, $prompt, $timeout, MyFileSystemHelper, URL, FOLDER) {

      $window.RAML.Settings.proxy = false;

      /**
       *
       * Save in data Storage entries.
       *
       * File structure are objects that contain the following attributes:
       * * path: The full path (including the filename).
       * * content: The content of the file (only valid for files).
       * * isFolder: A flag that indicates whether is a folder or file.
       */
      var service = {};
      var delay   = 500;

      function fileNotFoundMessage(path) {
        return 'file with path="' + path + '" does not exist';
      }

      function addChildren(entry, fn) {
        if (entry.type === FOLDER) {
          entry.children = fn(entry.path);
        }
      }
      function findFolder(path) {
        var entries = [];
        MyFileSystemHelper.forEach(function (entry) {
          if (entry.path.toLowerCase() === path.toLowerCase()) {
            addChildren(entry, findFiles);
            entries.push(entry);
          }
        });
        return entries.length > 0 ? entries[0] : null;
      }
      function findFiles(path) {
        if (path.lastIndexOf('/') !== path.length - 1) {
          path += '/';
        }

        var entries = [];
        MyFileSystemHelper.forEach(function (entry) {
          if (entry.path.toLowerCase() !== path.toLowerCase() &&
            extractParentPath(entry.path) + '/' === path) {
            addChildren(entry, findFiles);
            entries.push(entry);
          }
        });
        return entries;
      }

      service.supportsFolders = true;

      function validatePath(path) {
        if (path.indexOf('/') !== 0) {
          return {valid: false, reason: 'Path should start with "/"'};
        }
        return {valid: true};
      }

      function isValidParent(path) {
        var parent = extractParentPath(path);
        if (!MyFileSystemHelper.has(parent) && parent !== '') {
          return false;
        }
        return true;
      }

      function hasChildrens(path) {
        var has = false;
        MyFileSystemHelper.forEach(function (entry) {
          if (entry.path.indexOf(path + '/') === 0) {
            has = true;
          }
        });
        return has;
      }

      function extractNameFromPath(path) {
        var pathInfo = validatePath(path);

        if (!pathInfo.valid) {
          throw 'Invalid Path!';
        }

        // When the path is ended in '/'
        if (path.lastIndexOf('/') === path.length - 1) {
          path = path.slice(0, -1);
        }

        return path.slice(path.lastIndexOf('/') + 1);
      }

      function extractParentPath(path) {
        var pathInfo = validatePath(path);

        if (!pathInfo.valid) {
          throw 'Invalid Path!';
        }

        // When the path is ended in '/'
        if (path.lastIndexOf('/') === path.length - 1) {
          path = path.slice(0, -1);
        }

        return path.slice(0, path.lastIndexOf('/'));
      };

      /**
       * List files found in a given path.
       */
      service.directory = function (path) {
        var deferred = $q.defer();

        $timeout(function () {
          var isValidPath = validatePath(path);

          if (!isValidPath.valid) {
            deferred.reject(isValidPath.reason);
            return deferred.promise;
          }

          if (!MyFileSystemHelper.has('/')) {
            MyFileSystemHelper.set(path, {
              path: '/',
              name: '',
              type: FOLDER,
              meta: {
                'created': Math.round(new Date().getTime()/1000.0)
              }
            });
          }

          deferred.resolve(findFolder(path));
        }, delay);

        return deferred.promise;
      };

      /**
       * Persist a file to an existing folder.
       */
      service.save = function (path, content) {
        var deferred = $q.defer();

        $timeout(function () {
          var name = extractNameFromPath(path);
          var entry = MyFileSystemHelper.get(path);

          if (!isValidParent(path)){
            deferred.reject(new Error('Parent folder does not exists: ' + path));
            return deferred.promise;
          }

          var file = {};
          if (entry) {
            if (entry.type === FOLDER) {
              deferred.reject('file has the same name as a folder');
              return deferred.promise;
            }
            entry.content = content;
            entry.meta.lastUpdated = Math.round(new Date().getTime()/1000.0);
            file = entry;
          } else {
            file = {
              path: path,
              name: name,
              content: content,
              type: 'file',
              meta: {
                'created': Math.round(new Date().getTime()/1000.0)
              }
            };
          }

          MyFileSystemHelper.set(path, file);
          deferred.resolve();

        }, delay);

        return deferred.promise;
      };

      /**
       * Create the folders contained in a path.
       */
      service.createFolder = function (path) {
        var deferred = $q.defer();
        var isValidPath = validatePath(path);

        if (!isValidPath.valid) {
          deferred.reject(isValidPath.reason);
          return deferred.promise;
        }

        if (MyFileSystemHelper.has(path)) {
          deferred.reject(new Error('Folder already exists: ' + path));
          return deferred.promise;
        }

        var parent = extractParentPath(path);
        if (!MyFileSystemHelper.has(parent)) {
          deferred.reject(new Error('Parent folder does not exists: ' + path));
          return deferred.promise;
        }

        $timeout(function () {

          MyFileSystemHelper.set(path, {
            path: path,
            name: extractNameFromPath(path),
            type: FOLDER,
            meta: {
              'created': Math.round(new Date().getTime()/1000.0)
            }
          });

          deferred.resolve();
        }, delay);


        return deferred.promise;
      };

      /**
       * Loads the content of a file.
       */
      service.load = function (path) {
        var deferred = $q.defer();

        $timeout(function () {

          var entry = MyFileSystemHelper.get(path);
          if (entry && entry.type === 'file') {
            deferred.resolve(MyFileSystemHelper.get(path).content);
          } else {
            deferred.reject(fileNotFoundMessage(path));
          }

        }, delay);

        return deferred.promise;
      };

      /**
       * Removes a file or directory.
       */
      service.remove = function (path) {
        var deferred = $q.defer();

        $timeout(function () {
          var entry = MyFileSystemHelper.get(path);

          if (entry &&
            entry.type === FOLDER &&
            hasChildrens(path)) {
            deferred.reject('folder not empty');
            return deferred.promise;
          }

          MyFileSystemHelper.remove(path);
          deferred.resolve();
        }, delay);

        return deferred.promise;
      };

      /**
       * Renames a file or directory
       */
      service.rename = function (source, destination) {
        var deferred = $q.defer();

        $timeout(function () {
          var sourceEntry = MyFileSystemHelper.get(source);

          if (!sourceEntry) {
            deferred.reject('Source file or folder does not exists.');
            return deferred.promise;
          }

          var destinationEntry = MyFileSystemHelper.get(destination);
          if (destinationEntry) {
            deferred.reject('File or folder already exists.');
            return deferred.promise;
          }

          if (!isValidParent(destination)) {
            deferred.reject('Destination folder does not exist.');
            return deferred.promise;
          }

          sourceEntry.path = destination;
          sourceEntry.name = extractNameFromPath(destination);

          MyFileSystemHelper.remove(destination);
          MyFileSystemHelper.remove(source);
          MyFileSystemHelper.set(destination, sourceEntry);

          if (sourceEntry.type === FOLDER) {
            // if (!isValidPath(destination)) {
            //   deferred.reject('Destination is not a valid folder');
            //   return deferred.promise;
            // }
            //move all child items
            MyFileSystemHelper.forEach(function (entry) {
              if (entry.path.toLowerCase() !== source.toLowerCase() &&
                entry.path.indexOf(source) === 0) {
                var newPath = destination + entry.path.substring(source.length);
                MyFileSystemHelper.remove(entry.path);
                entry.path = newPath;
                MyFileSystemHelper.set(newPath, entry);
              }
            });
          }

          deferred.resolve();
        }, delay);

        return deferred.promise;
      };

      service.exportFiles = function exportFiles() {
        var jszip = new $window.JSZip();
        MyFileSystemHelper.forEach(function (item) {
          // Skip root folder
          if (item.path === '/') {
            return;
          }

          // Skip meta files
          if (item.name.slice(-5) === '.meta') {
            return;
          }

          var path = item.path.slice(1); // Remove starting slash
          item.type === FOLDER ? jszip.folder(path) : jszip.file(path, item.content);
        });

        var fileName = $prompt('Please enter a ZIP file name:', 'api.zip');
        fileName && $window.saveAs(jszip.generate({type: 'blob'}), fileName);
      };

      return service;
    })
    .run(function (MyFileSystem, config, $rootScope) {
      // Set MyFileSystem as the filesystem to use
      config.set('fsFactory', 'MyFileSystem');

      // In case you want to send notifications to the user
      // (for instance, that he must login to save).
      // The expires flags means whether
      // it should be hidden after a period of time or the
      // user should dismiss it manually.
      $rootScope.$broadcast('event:notification',
        {message: 'File saved.', expires: true});
    });

    </script>
  </body>
</html>
